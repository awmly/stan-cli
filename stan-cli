#! /bin/sh

######################################
#### STAN Command Line Interface #####
############# LOCAL BIN ##############
########### VERSION 1.0.0 ############
######## DATE 17:13 - 05/02/15 #######
######################################

# Get passed arguments
METHOD="$1"
ARGS=("$@")

# Set vars
HR===============================================

# Set text colours
GREEN=`tput setaf 2`
RED=`tput setaf 1`
RESET=`tput sgr0`

# Set complete strings
UPLOAD="${HR}\n${GREEN}✔ UPLOAD COMPLETE ${RESET}\n${HR}"
REBASE="${HR}\n${GREEN}✔ REBASE COMPLETE ${RESET}\n${HR}"
IMPORT="${HR}\n${GREEN}✔ DATABASE IMPORTED ${RESET}\n${HR}"
EXPORT="${HR}\n${GREEN}✔ DATABASE EXPORTED ${RESET}\n${HR}"
DBCONF="${HR}\n${GREEN}✔ DATABASE CONFIG FILES CREATED ${RESET}\n${HR}"
SNAPSHOT="${HR}\n${GREEN}✔ SNAPSHOT CREATED ${RESET}\n${HR}"
DEPLOY="${HR}\n${GREEN}✔ SITE DEPLOYED TO PRODUCTION ${RESET}\n${HR}"
RESTORE="${HR}\n${GREEN}✔ RESTORE COMPLETE ${RESET}\n${HR}"
OPTIMISE="${HR}\n${GREEN}✔ IMAGE OPTIMISATION COMPLETE ${RESET}\n${HR}"

# Set error strings
NOTFOUND="${HR}\n${RED}COMMAND NOT FOUND${RESET}\n${HR}"
RESTOREERROR="${HR}\n${RED}RESTORE SNAPSHOT NOT FOUND${RESET}\nPlease ensure snapshots/restore.tar.gz exists\n${HR}"

# Set Propts
DEPLOYPROMPT="This will copy the staging database and httpdocs to the production server - are you sure?"
RESTOREPROMPT="This will delete the current production server and restore it from a snapshot - are you sure?"

# Define install Grunt function
installGrunt(){

  npm install
  bower install
  composer install
  grunt update

}


# Define check if dir is empty function
checkIfDirIsEmpty(){

  # Check if dir is empty - except for git folder auto created by github app
  if  [ "$(ls -A | grep -v .git)" ]; then
    echo -e $NOTEMPTY
    exit 1
  fi

}


# Define check if stan is installed function
checkIfStanIsInstalled(){

  # Check if stan-cli file exists
  if [ ! -f "./stan-cli" ]; then
    echo -e $NOSTAN
    exit 1
  fi

}


# Define get config var function
getConfigVar(){

  # Include config file and echo out variable - discard any php warnings/notices
  php -r "include('httpdocs/config/config.php'); echo ${1};" 2> /dev/null

}


# Define prompt function
prompt(){

  # Confirm deployment
  echo -e ${1}

  # Show Y/N choices
  select YN in "Yes" "No"; do
      case $YN in
          Yes ) break;;
          No ) exit;;
      esac
  done

}

# Define upload method
if [ "$METHOD" = "upload" ]; then

  # Set folder permissions
  find httpdocs/* -type d -print0 | xargs -0 chmod 0755
  find httpdocs/* -type f -print0 | xargs -0 chmod 0644
  chmod -R 0777 httpdocs/cache

  # Get remote from config
  REMOTE=$( getConfigVar "REMOTE" )

  # If upload is scripts
  if [ "${ARGS[1]}" = "scripts" ]; then

    # Upload scripts
    rsync -trp --omit-dir-times --delete scripts/ ${REMOTE}scripts/

    # Upload stan-cli
    rsync -trp --omit-dir-times --delete stan-cli ${REMOTE}stan-cli

  else

    # Get staging server config
    STAGING_SERVER=$( getConfigVar "STAGING_SERVER" )

    # Check which env to upload to
    if [ "${ARGS[1]}" = "production" ] || [ "$STAGING_SERVER" = "" ]; then

      # Production
      REMOTE_PATH="httpdocs/"

    else

      # Staging
      REMOTE_PATH="staging/"

    fi

    # Upload httpdocs
    rsync -trp --omit-dir-times --delete --exclude=cache/images --exclude=cache/tmp --exclude=cache/null httpdocs/ ${REMOTE}${REMOTE_PATH}

    # Upload to CDN
    grunt cloudfiles

  fi

  # Show complete text
  echo -e $UPLOAD

# Define deploy method
elif [ "$METHOD" = "deploy" ]; then

  # Confirm deployment
  prompt $DEPLOYPROMPT

  # Create snapshot
  stan snapshot

  # Copy staging to production
  rsync -trp --omit-dir-times --delete staging/ httpdocs/

  # Export staging db
  stan db exportstaging

  # Load in to production db
  stan db importproduction

  # Load custom deploy
  scripts/deploy.sh

  # Show complete text
  echo -e $DEPLOY

# Define snapshot method
elif [ "$METHOD" = "snapshot" ]; then

  # Get domain
  DOMAIN=$( getConfigVar "DOMAIN" )

  # Set timestamp
  TIMESTAMP=$( date +"%Y-%m-%d_%H-%M-%S" )

  # Create db conf files
  stan db conf

  # Export production db
  stan db exportproduction

  # Move db to archive folder
  mv database/database.sql httpdocs/database.sql

  # Make archive directory
  tar -zcvf snapshots/${DOMAIN}-${TIMESTAMP}.tar.gz httpdocs/ > /dev/null

  # Show complete text
  echo -e $SNAPSHOT

# Define restore method
elif [ "$METHOD" = "restore" ]; then

  # Confirm restore
  prompt $RESTOREPROMPT

  # Check restore file is present
  if [ -f "snapshots/restore.tar.gz" ]; then

    # Extract restore file
    tar -zxvf snapshots/restore.tar.gz

    # Move database to database folder
    mv snapshots/restore/database.sql databases/database.sql

    # Restore database
    stan db importproduction

    # Remove database
    rm snapshots/restore/database.sql

    # Restore httpdocs
    rsync -trp --omit-dir-times --delete snapshots/restore/ httpdocs/

    # Ensure cache directory is writeable
    chmod -R 0777 httpdocs/cache

    # Delete extracted folder
    rm -rf snapshots/restore

    # Show complete text
    echo $RESTORE

  else

    # Show error text
    echo $RESTOREERROR

  fi

# Define syncdb method
elif [ "$METHOD" = "db" ]; then

  if [ "${ARGS[1]}" = "conf" ]; then

    # Get production db variables from config
    DBHOST=$( getConfigVar "DBHOST" )
    DBUSER=$( getConfigVar "DBUSER" )
    DBPASS=$( getConfigVar "DBPASS" )

    # Create production mysql cnf file
    echo "[client]" > database/production.cnf
    echo "host = ${DBHOST}" >> database/production.cnf
    echo "user = ${DBUSER}" >> database/production.cnf
    echo "password = ${DBPASS}" >> database/production.cnf

    # Get staging db variables from config
    DBHOST=$( getConfigVar "DBHOST_STAGING" )
    DBUSER=$( getConfigVar "DBUSER_STAGING" )
    DBPASS=$( getConfigVar "DBPASS_STAGING" )

    # Create staging mysql cnf file
    echo "[client]" > database/staging.cnf
    echo "host = ${DBHOST}" >> database/staging.cnf
    echo "user = ${DBUSER}" >> database/staging.cnf
    echo "password = ${DBPASS}" >> database/staging.cnf

    # Get local db variables from config
    DBHOST=$( getConfigVar "DBHOST_LOCAL" )
    DBUSER=$( getConfigVar "DBUSER_LOCAL" )
    DBPASS=$( getConfigVar "DBPASS_LOCAL" )

    # Create local mysql cnf file
    echo "[client]" > database/local.cnf
    echo "host = ${DBHOST}" >> database/local.cnf
    echo "user = ${DBUSER}" >> database/local.cnf
    echo "password = ${DBPASS}" >> database/local.cnf

    # Show complete text
    echo -e $DBCONF

  elif [ "${ARGS[1]}" = "exportproduction" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME" )

    # Run mysqldump command
    mysqldump --defaults-extra-file=database/production.cnf --complete-insert --default-character-set=utf8 $DBNAME > database/database.sql

    # Show complete text
    echo -e $EXPORT

  elif  [ "${ARGS[1]}" = "importproduction" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME" )

    # Load database
    mysql --defaults-extra-file=database/production.cnf $DBNAME < database/database.sql

    # Show complete text
    echo -e $IMPORT

  elif [ "${ARGS[1]}" = "exportstaging" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME_STAGING" )

    # Run mysqldump command
    mysqldump --defaults-extra-file=database/staging.cnf --complete-insert --default-character-set=utf8 $DBNAME > database/database.sql

    # Show complete text
    echo -e $EXPORT

  elif  [ "${ARGS[1]}" = "importstaging" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME_STAGING" )

    # Load database
    mysql --defaults-extra-file=database/staging.cnf $DBNAME < database/database.sql

    # Show complete text
    echo -e $IMPORT

  elif [ "${ARGS[1]}" = "exportlocal" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME_LOCAL" )

    # Run mysqldump command
    mysqldump --defaults-extra-file=database/local.cnf --complete-insert --default-character-set=utf8 $DBNAME > database/database.sql

    # Show complete text
    echo -e $EXPORT

  elif  [ "${ARGS[1]}" = "importlocal" ]; then

    # Get database name
    DBNAME=$( getConfigVar "DBNAME_LOCAL" )

    # Load database
    mysql --defaults-extra-file=database/local.cnf $DBNAME < database/database.sql

    # Show complete text
    echo -e $IMPORT

  else

    echo -e $NOTFOUND

  fi

# Define speed test method
elif [ "$METHOD" = "speedtest" ]; then

  # Get SIET_URL from config file
  SITE_URL=$( getConfigVar "SITE_URL" )

  # Run sitespeed.io test
  sitespeed.io -u $SITE_URL -r tests/sitespeed.io/ -j 20 -s /contact-us

  # Run GT Metrix (Page speed and Y Slow)
  php tests/gtmetrix/run-test.php

# Define rebase method
elif [ "$METHOD" = "rebase" ]; then

  # Get current git status
  GIT_STATUS=$( git status )

  # Check if there are any unstaged files
  if [[ $GIT_STATUS == *"nothing to commit"* ]]; then

    # Rebase master
    git pull --rebase -p origin master

  else

    # Stash any un-commited files
    git stash

    # Rebase master
    git pull --rebase -p origin master

    # Unstash files
    git stash apply

  fi

  # Show complete text
  echo -e $REBASE

# Define optimise method
elif [ "$METHOD" = "optimise" ]; then

  jpegoptim httpdocs/assets/frontend/images/*.jpg
  optipng -o5 httpdocs/assets/frontend/images/*.png

  echo -e $OPTIMISE

# Define default action
elif [ "$METHOD" = "" ]; then

  # Rebase from remote
  stan rebase

  # Update libs
  grunt update

  # Open atom
  atom ./

  # Start mysql server
  mysql.server start

  # Export current staging db and local it in to local server
  stan db exportstaging
  stan db importlocal

  # Open frontend and backend in Chrome
  open -a 'Google Chrome' http://stan:4000/stan/
  open -a 'Google Chrome' http://stan:4000/

  # Start grunt server
  grunt serve

# Define help method
else

  echo "HELP"

fi
